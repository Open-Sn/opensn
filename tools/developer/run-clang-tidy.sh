#!/usr/bin/env bash

user_extra_before=""
user_extra_arg=""
positional=()
before_opt=()
arg_opt=()
had_issues=0
tmp_log="$(mktemp -t clang_tidy.XXXXXX)"
cleanup() { rm -f "$tmp_log"; }
trap cleanup EXIT

set -Eeuo pipefail

usage() {
  cat <<EOF
Usage: run-clang-tidy.sh [-h] [FILENAME]

OpenSn-specific clang-tidy script.

Runs clang-tidy on the entire OpenSn repository or on a single source file.

This command should be run from the root of the OpenSn repository.

For example, to analyze the entire repository, run:
tools/developer/run-clang-tidy.sh

To analyze a single source (.cc) file, run:
tools/developer/run-clang-tidy.sh framework/utils/timer.cc:

Options:
  -h, --help    Show this help and exit.

EOF
}

# Parse command-line arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help) usage; exit 0 ;;
    -extra-arg-before=*)
      user_extra_before="${1#*=}"; shift; continue ;;
    -extra-arg-before)
      shift; user_extra_before="${1:-}"; [[ -n "${1:-}" ]] && shift; continue ;;
    -extra-arg=*)
      user_extra_arg="${1#*=}"; shift; continue ;;
    -extra-arg)
      shift; user_extra_arg="${1:-}"; [[ -n "${1:-}" ]] && shift; continue ;;
    --) shift; break ;;
    -*) echo "Unknown option: $1" >&2; usage; exit 2 ;;
    *) positional+=( "$1" ); shift; continue ;;
  esac
done

# Collect anything after '--'
if [[ $# -gt 0 ]]; then positional+=( "$@" ); fi

if (( ${#positional[@]} > 1 )); then
  echo "Error: too many arguments" >&2
  usage
  exit 2
fi

if ! command -v run-clang-tidy >/dev/null 2>&1; then
  echo "Error: 'run-clang-tidy' not found." >&2
  echo "       Install clang-tidy (LLVM) or add 'run-clang-tidy' to your PATH." >&2
  exit 127
fi

repo=$(git rev-parse --show-toplevel)
header_filter="^${repo}/(framework|modules|python)/"


if [[ -n "${user_extra_before:-}" ]]; then
  before_opt=( -extra-arg-before="$user_extra_before" )
fi
if [[ -n "${user_extra_arg:-}" ]]; then
  arg_opt=( -extra-arg="$user_extra_arg" )
fi

if (( ${#positional[@]} == 1 )); then
  file="${positional[0]}"
  if [[ -f build/compile_commands.json ]]; then
    if ! grep -Fq -- "$file" build/compile_commands.json; then
      echo "Error: '$file' not found in build/compile_commands.json." >&2
      echo "       Ensure itâ€™s part of a target and rebuild the DB." >&2
      exit 1
    fi
  fi
  run-clang-tidy -p build -header-filter="$header_filter" ${before_opt[@]+"${before_opt[@]}"} \
                 ${arg_opt[@]+"${arg_opt[@]}"} "$file" -warnings-as-errors='*' | tee -a "$tmp_log"
else
  run-clang-tidy -p build -header-filter="$header_filter" ${before_opt[@]+"${before_opt[@]}"} \
                 ${arg_opt[@]+"${arg_opt[@]}"} "${repo}/framework" "${repo}/modules" "${repo}/python" \
                 -warnings-as-errors='*' | tee -a "$tmp_log"
fi

# run-clang-tidy does not generate an exit status based on errors or warnings
# generated by clang-tidy. We'll have to do this ourselves by parsing the
# clang-tidy output.
if grep -E '^[^:]+:[0-9]+:[0-9]+: (warning|error): ' "$tmp_log" >/dev/null; then
  had_issues=1
fi

if (( ${had_issues} )); then
  echo "clang-tidy reported issues (treating warnings as errors)." >&2
  exit 1
fi
