diff --git a/modules/linear_boltzmann_solvers/discrete_ordinates_problem/discrete_ordinates_problem.cc b/modules/linear_boltzmann_solvers/discrete_ordinates_problem/discrete_ordinates_problem.cc
index 6af1b65f..78d7b47a 100644
--- a/modules/linear_boltzmann_solvers/discrete_ordinates_problem/discrete_ordinates_problem.cc
+++ b/modules/linear_boltzmann_solvers/discrete_ordinates_problem/discrete_ordinates_problem.cc
@@ -494,22 +494,7 @@ DiscreteOrdinatesProblem::Initialize()
   // Make face histogram
   grid_face_histogram_ = grid_->MakeGridFaceHistogram();
 
-  psi_new_local_.clear();
-  psi_old_local_.clear();
-  for (auto& groupset : groupsets_)
-  {
-    psi_new_local_.emplace_back();
-    psi_old_local_.emplace_back();
-    const bool save_old =
-      (sweep_chunk_mode_.value_or(SweepChunkMode::Default) == SweepChunkMode::TimeDependent);
-    if (options_.save_angular_flux || save_old)
-    {
-      size_t num_ang_unknowns = discretization_->GetNumLocalDOFs(groupset.psi_uk_man_);
-      psi_new_local_.back().assign(num_ang_unknowns, 0.0);
-      if (save_old)
-        psi_old_local_.back().assign(num_ang_unknowns, 0.0);
-    }
-  }
+  RefreshAngularFluxStorage();
 
   const auto grid_dim = grid_->GetDimension();
   for (auto& groupset : groupsets_)
@@ -541,24 +526,67 @@ DiscreteOrdinatesProblem::Initialize()
 }
 
 void
-DiscreteOrdinatesProblem::SetSweepChunkMode(SweepChunkMode mode)
+DiscreteOrdinatesProblem::SetOptions(const InputParameters& input)
 {
-  sweep_chunk_mode_ = mode;
-  if (mode == SweepChunkMode::TimeDependent && discretization_)
+  LBSProblem::SetOptions(input);
+  RefreshAngularFluxStorage();
+}
+
+void
+DiscreteOrdinatesProblem::RefreshAngularFluxStorage()
+{
+  if (not discretization_)
+    return;
+
+  const bool is_time_dependent =
+    (sweep_chunk_mode_.value_or(SweepChunkMode::Default) == SweepChunkMode::TimeDependent);
+  const bool need_psi_new = options_.save_angular_flux or is_time_dependent;
+  const bool need_psi_old = is_time_dependent;
+
+  psi_new_local_.resize(groupsets_.size());
+  psi_old_local_.resize(groupsets_.size());
+
+  for (const auto& groupset : groupsets_)
   {
-    if (psi_old_local_.empty())
-      return;
-    if (psi_old_local_.front().empty())
+    const size_t gid = groupset.id;
+    const size_t num_ang_unknowns = discretization_->GetNumLocalDOFs(groupset.psi_uk_man_);
+
+    auto& psi_new = psi_new_local_.at(gid);
+    if (need_psi_new)
+      psi_new.assign(num_ang_unknowns, 0.0);
+    else
     {
-      for (auto& groupset : groupsets_)
-      {
-        size_t num_ang_unknowns = discretization_->GetNumLocalDOFs(groupset.psi_uk_man_);
-        psi_old_local_.at(groupset.id).assign(num_ang_unknowns, 0.0);
-      }
+      psi_new.clear();
+      psi_new.shrink_to_fit();
+    }
+
+    auto& psi_old = psi_old_local_.at(gid);
+    if (need_psi_old)
+      psi_old.assign(num_ang_unknowns, 0.0);
+    else
+    {
+      psi_old.clear();
+      psi_old.shrink_to_fit();
     }
   }
 }
 
+void
+DiscreteOrdinatesProblem::SetSweepChunkMode(SweepChunkMode mode)
+{
+  sweep_chunk_mode_ = mode;
+  RefreshAngularFluxStorage();
+  AdvanceStateEpoch();
+}
+
+void
+DiscreteOrdinatesProblem::ResetSweepChunkMode()
+{
+  sweep_chunk_mode_.reset();
+  RefreshAngularFluxStorage();
+  AdvanceStateEpoch();
+}
+
 void
 DiscreteOrdinatesProblem::EnableTimeDependentMode()
 {
diff --git a/modules/linear_boltzmann_solvers/discrete_ordinates_problem/discrete_ordinates_problem.h b/modules/linear_boltzmann_solvers/discrete_ordinates_problem/discrete_ordinates_problem.h
index fd494e9b..85e2d64e 100644
--- a/modules/linear_boltzmann_solvers/discrete_ordinates_problem/discrete_ordinates_problem.h
+++ b/modules/linear_boltzmann_solvers/discrete_ordinates_problem/discrete_ordinates_problem.h
@@ -33,7 +33,7 @@ public:
   };
 
   void SetSweepChunkMode(SweepChunkMode mode);
-  void ResetSweepChunkMode() { sweep_chunk_mode_.reset(); }
+  void ResetSweepChunkMode();
   bool IsTimeDependent() const
   {
     return sweep_chunk_mode_.value_or(SweepChunkMode::Default) == SweepChunkMode::TimeDependent;
@@ -80,6 +80,7 @@ public:
   void PrintSimHeader() override;
 
   void Initialize() override;
+  void SetOptions(const InputParameters& input) override;
 
   /// Returns the sweep boundaries as a read only reference
   const std::map<uint64_t, std::shared_ptr<SweepBoundary>>& GetSweepBoundaries() const;
@@ -176,6 +177,8 @@ protected:
   std::map<std::tuple<size_t, size_t, size_t>, size_t> angular_flux_field_functions_local_map_;
 
 private:
+  void RefreshAngularFluxStorage();
+
   void CreateAAHD_FLUDSCommonData();
   std::shared_ptr<FLUDS> CreateAAHD_FLUDS(unsigned int num_groups,
                                           std::size_t num_angles,
diff --git a/modules/linear_boltzmann_solvers/lbs_problem/lbs_problem.cc b/modules/linear_boltzmann_solvers/lbs_problem/lbs_problem.cc
index 3833c961..a0220ea0 100644
--- a/modules/linear_boltzmann_solvers/lbs_problem/lbs_problem.cc
+++ b/modules/linear_boltzmann_solvers/lbs_problem/lbs_problem.cc
@@ -413,6 +413,7 @@ void
 LBSProblem::SetActiveSetSourceFunction(SetSourceFunction source_function)
 {
   active_set_source_function_ = std::move(source_function);
+  AdvanceStateEpoch();
 }
 
 std::shared_ptr<AGSLinearSolver>
@@ -666,6 +667,14 @@ LBSProblem::SetOptions(const InputParameters& input)
     opensn::mpi_comm.barrier();
     UpdateRestartWriteTime();
   }
+
+  AdvanceStateEpoch();
+}
+
+void
+LBSProblem::AdvanceStateEpoch()
+{
+  ++state_epoch_;
 }
 
 void
diff --git a/modules/linear_boltzmann_solvers/lbs_problem/lbs_problem.h b/modules/linear_boltzmann_solvers/lbs_problem/lbs_problem.h
index b0b56029..5049929c 100644
--- a/modules/linear_boltzmann_solvers/lbs_problem/lbs_problem.h
+++ b/modules/linear_boltzmann_solvers/lbs_problem/lbs_problem.h
@@ -18,6 +18,7 @@
 #include "framework/math/geometry.h"
 #include <petscksp.h>
 #include <any>
+#include <cstdint>
 #include <chrono>
 
 namespace opensn
@@ -50,7 +51,9 @@ public:
   /// Returns a constant reference to the solver options.
   const LBSOptions& GetOptions() const;
 
-  void SetOptions(const InputParameters& input);
+  virtual void SetOptions(const InputParameters& input);
+  uint64_t GetStateEpoch() const { return state_epoch_; }
+  void AdvanceStateEpoch();
 
   /// Returns simulation time in seconds for time dependent problems
   double GetTime() const;
@@ -293,6 +296,7 @@ protected:
   virtual void ZeroSolutions() = 0;
 
   LBSOptions options_;
+  uint64_t state_epoch_ = 0;
   double time_ = 0.0;
   double theta_ = 1.0;
   double dt_ = 1.0;
diff --git a/modules/linear_boltzmann_solvers/solvers/transient_solver.cc b/modules/linear_boltzmann_solvers/solvers/transient_solver.cc
index 26d13d32..8bfb6cc9 100644
--- a/modules/linear_boltzmann_solvers/solvers/transient_solver.cc
+++ b/modules/linear_boltzmann_solvers/solvers/transient_solver.cc
@@ -71,6 +71,17 @@ TransientSolver::TransientSolver(const InputParameters& params)
   do_problem_->SetTheta(params.GetParamValue<double>("theta"));
 }
 
+TransientSolver::~TransientSolver()
+{
+  try
+  {
+    RestoreProblemStateFromTransient();
+  }
+  catch (...)
+  {
+  }
+}
+
 void
 TransientSolver::RefreshLocalViews()
 {
@@ -90,105 +101,160 @@ TransientSolver::UpdateHasFissionableMaterial()
 }
 
 void
-TransientSolver::Initialize()
+TransientSolver::SaveProblemStateForTransient()
 {
-  log.Log() << "Initializing " << GetName() << ".";
-  enforce_stop_time_ = false;
+  if (has_saved_problem_state_)
+    return;
 
-  // Ensure angular fluxes are available from the initial condition.
-  auto& options = do_problem_->GetOptions();
-  options.save_angular_flux = true;
-  do_problem_->SetTime(current_time_);
+  previous_save_angular_flux_ = do_problem_->GetOptions().save_angular_flux;
+  previous_active_set_source_function_ = do_problem_->GetActiveSetSourceFunction();
+  has_saved_problem_state_ = true;
+}
 
-  const std::string& init_state = initial_state_;
-  RefreshLocalViews();
-  if (not phi_new_local_ or phi_new_local_->empty())
-  {
-    if (init_state != "zero")
-      throw std::runtime_error(GetName() + ": Problem must be initialized before TransientSolver.");
-    do_problem_->Initialize();
-    RefreshLocalViews();
-  }
-  if (not phi_new_local_ or phi_new_local_->empty())
-    throw std::runtime_error(GetName() + ": Problem initialization failed.");
+void
+TransientSolver::RestoreProblemStateFromTransient()
+{
+  if (not has_saved_problem_state_)
+    return;
 
-  if (init_state == "zero")
+  auto& options = do_problem_->GetOptions();
+  if (options.save_angular_flux != previous_save_angular_flux_)
   {
-    std::fill(phi_new_local_->begin(), phi_new_local_->end(), 0.0);
-    std::fill(phi_old_local_->begin(), phi_old_local_->end(), 0.0);
-    std::fill(precursor_new_local_->begin(), precursor_new_local_->end(), 0.0);
-    for (auto& psi : *psi_new_local_)
-      std::fill(psi.begin(), psi.end(), 0.0);
+    options.save_angular_flux = previous_save_angular_flux_;
+    do_problem_->AdvanceStateEpoch();
   }
 
-  // Set time-dependent mode and rebuild WGS/AGS solvers for time-dependent sweep chunks
-  do_problem_->EnableTimeDependentMode();
-  do_problem_->SetTime(current_time_);
+  do_problem_->SetActiveSetSourceFunction(previous_active_set_source_function_);
+  has_saved_problem_state_ = false;
+}
+
+void
+TransientSolver::ApplyTransientProblemState()
+{
+  auto& options = do_problem_->GetOptions();
+  if (not options.save_angular_flux)
   {
-    auto src_function = std::make_shared<TransientSourceFunction>(*do_problem_);
-    do_problem_->SetActiveSetSourceFunction(
-      [src_function](auto&& p1, auto&& p2, auto&& p3, auto&& p4)
-      {
-        (*src_function)(std::forward<decltype(p1)>(p1),
-                        std::forward<decltype(p2)>(p2),
-                        std::forward<decltype(p3)>(p3),
-                        std::forward<decltype(p4)>(p4));
-      });
+    options.save_angular_flux = true;
+    do_problem_->AdvanceStateEpoch();
   }
-  do_problem_->ReinitializeSolverSchemes();
-  RefreshLocalViews();
-  ags_solver_ = do_problem_->GetAGSSolver();
-  UpdateHasFissionableMaterial();
-  if (options.use_precursors and not has_fissionable_material_)
-    log.Log0Warning() << GetName()
-                      << ": use_precursors is enabled but no fissionable material is present.";
-  if ((not options.use_precursors) and has_fissionable_material_)
-    log.Log0Warning() << GetName()
-                      << ": fissionable material is present but use_precursors is disabled. "
-                         "Running prompt-only transient.";
-
-  // Configure fission sources for transient solve. For transients
-  // we treat fission as an explicit source (RHS), not on the LHS.
-  for (auto& wgs_solver : do_problem_->GetWGSSolvers())
+
+  auto src_function = std::make_shared<TransientSourceFunction>(*do_problem_);
+  do_problem_->SetActiveSetSourceFunction(
+    [src_function](auto&& p1, auto&& p2, auto&& p3, auto&& p4)
+    {
+      (*src_function)(std::forward<decltype(p1)>(p1),
+                      std::forward<decltype(p2)>(p2),
+                      std::forward<decltype(p3)>(p3),
+                      std::forward<decltype(p4)>(p4));
+    });
+}
+
+void
+TransientSolver::EnsureInitializedStateIsCurrent(const std::string& caller) const
+{
+  OpenSnLogicalErrorIf(not initialized_, GetName() + ": Initialize must be called before " + caller +
+                                         ".");
+  OpenSnLogicalErrorIf(initialized_state_epoch_ != do_problem_->GetStateEpoch(),
+                       GetName() + ": Problem state changed since Initialize. Reinitialize before " +
+                         caller + ".");
+}
+
+void
+TransientSolver::Initialize()
+{
+  log.Log() << "Initializing " << GetName() << ".";
+  enforce_stop_time_ = false;
+  RestoreProblemStateFromTransient();
+  SaveProblemStateForTransient();
+  ApplyTransientProblemState();
+
+  try
   {
-    auto context = wgs_solver->GetContext();
-    auto wgs_context = std::dynamic_pointer_cast<WGSContext>(context);
-    if (not wgs_context)
-      throw std::logic_error(GetName() + ": Cast to WGSContext failed.");
+    auto& options = do_problem_->GetOptions();
+    do_problem_->SetTime(current_time_);
 
-    wgs_context->lhs_src_scope.Unset(APPLY_WGS_FISSION_SOURCES);
-    wgs_context->rhs_src_scope |= APPLY_WGS_FISSION_SOURCES;
-    wgs_context->rhs_src_scope |= APPLY_AGS_FISSION_SOURCES;
-  }
+    const std::string& init_state = initial_state_;
+    RefreshLocalViews();
+    if (not phi_new_local_ or phi_new_local_->empty())
+    {
+      OpenSnLogicalErrorIf(init_state != "zero",
+                           GetName() + ": Problem must be initialized before TransientSolver.");
+      do_problem_->Initialize();
+      RefreshLocalViews();
+    }
+    OpenSnLogicalErrorIf(not phi_new_local_ or phi_new_local_->empty(),
+                         GetName() + ": Problem initialization failed.");
 
-  // Sync psi_old with the steady-state angular flux before enabling RHS time term
-  do_problem_->UpdatePsiOld();
+    if (init_state == "zero")
+    {
+      std::fill(phi_new_local_->begin(), phi_new_local_->end(), 0.0);
+      std::fill(phi_old_local_->begin(), phi_old_local_->end(), 0.0);
+      std::fill(precursor_new_local_->begin(), precursor_new_local_->end(), 0.0);
+      for (auto& psi : *psi_new_local_)
+        std::fill(psi.begin(), psi.end(), 0.0);
+    }
 
-  // Keep initialization side-effect free: zero/existing differ only by
-  // initial-condition setup, not by additional sweeps.
-  *phi_old_local_ = *phi_new_local_;
+    // Set time-dependent mode and rebuild WGS/AGS solvers for time-dependent sweep chunks
+    do_problem_->EnableTimeDependentMode();
+    do_problem_->SetTime(current_time_);
+    do_problem_->ReinitializeSolverSchemes();
+    RefreshLocalViews();
+    ags_solver_ = do_problem_->GetAGSSolver();
+    UpdateHasFissionableMaterial();
+    if (options.use_precursors and not has_fissionable_material_)
+      log.Log0Warning() << GetName()
+                        << ": use_precursors is enabled but no fissionable material is present.";
+    if ((not options.use_precursors) and has_fissionable_material_)
+      log.Log0Warning() << GetName()
+                        << ": fissionable material is present but use_precursors is disabled. "
+                           "Running prompt-only transient.";
+
+    // Configure fission sources for transient solve. For transients
+    // we treat fission as an explicit source (RHS), not on the LHS.
+    for (auto& wgs_solver : do_problem_->GetWGSSolvers())
+    {
+      auto context = wgs_solver->GetContext();
+      auto wgs_context = std::dynamic_pointer_cast<WGSContext>(context);
+      OpenSnLogicalErrorIf(not wgs_context, GetName() + ": Cast to WGSContext failed.");
 
-  // Sync with the current solution
-  phi_prev_local_ = *phi_new_local_;
-  precursor_prev_local_ = *precursor_new_local_;
-  psi_prev_local_ = *psi_new_local_;
+      wgs_context->lhs_src_scope.Unset(APPLY_WGS_FISSION_SOURCES);
+      wgs_context->rhs_src_scope |= APPLY_WGS_FISSION_SOURCES;
+      wgs_context->rhs_src_scope |= APPLY_AGS_FISSION_SOURCES;
+    }
+
+    // Sync psi_old with the steady-state angular flux before enabling RHS time term
+    do_problem_->UpdatePsiOld();
 
-  initialized_ = true;
+    // Keep initialization side-effect free: zero/existing differ only by
+    // initial-condition setup, not by additional sweeps.
+    *phi_old_local_ = *phi_new_local_;
+
+    // Sync with the current solution
+    phi_prev_local_ = *phi_new_local_;
+    precursor_prev_local_ = *precursor_new_local_;
+
+    initialized_ = true;
+    initialized_state_epoch_ = do_problem_->GetStateEpoch();
+  }
+  catch (...)
+  {
+    initialized_ = false;
+    RestoreProblemStateFromTransient();
+    throw;
+  }
 }
 
 void
 TransientSolver::Execute()
 {
   log.Log() << "Executing " << GetName() << ".";
-  if (not initialized_)
-    throw std::runtime_error(GetName() + ": Initialize must be called before Execute.");
+  EnsureInitializedStateIsCurrent("Execute");
 
   const double t0 = current_time_;
   const double tf = stop_time_;
   const double dt_nominal = do_problem_->GetTimeStep();
 
-  if (tf < t0)
-    throw std::runtime_error(GetName() + ": stop_time must be >= current_time");
+  OpenSnInvalidArgumentIf(tf < t0, GetName() + ": stop_time must be >= current_time");
 
   const double tol =
     64.0 * std::numeric_limits<double>::epsilon() * std::max({1.0, std::abs(tf), std::abs(t0)});
@@ -211,8 +277,7 @@ TransientSolver::Execute()
         pre_advance_callback_();
 
       const double dt = do_problem_->GetTimeStep();
-      if (dt <= 0.0)
-        throw std::runtime_error(GetName() + ": dt must be positive");
+      OpenSnLogicalErrorIf(dt <= 0.0, GetName() + ": dt must be positive");
       const double step_dt = (remaining < dt) ? remaining : dt;
       do_problem_->SetTimeStep(step_dt);
       do_problem_->SetTime(current_time_);
@@ -245,8 +310,7 @@ void
 TransientSolver::Advance()
 {
   auto& options = do_problem_->GetOptions();
-  if (not initialized_)
-    throw std::runtime_error(GetName() + ": Initialize must be called before Advance.");
+  EnsureInitializedStateIsCurrent("Advance");
   if (enforce_stop_time_ and stop_time_ <= current_time_)
   {
     if (verbose_)
@@ -284,8 +348,7 @@ TransientSolver::Advance()
     if (current_solver.get() != ags_solver_.get())
       ags_solver_ = std::move(current_solver);
   }
-  if (not ags_solver_)
-    throw std::runtime_error(GetName() + ": AGS solver not available.");
+  OpenSnLogicalErrorIf(not ags_solver_, GetName() + ": AGS solver not available.");
   ags_solver_->Solve();
 
   // For non-fission source-only problems, match TimeDependentSourceSolver behavior.
@@ -312,7 +375,6 @@ TransientSolver::Advance()
   current_time_ += dt;
   do_problem_->SetTime(current_time_);
   phi_prev_local_ = *phi_new_local_;
-  psi_prev_local_ = *psi_new_local_;
   do_problem_->UpdateFieldFunctions();
   do_problem_->UpdatePsiOld();
   if (options.use_precursors)
diff --git a/modules/linear_boltzmann_solvers/solvers/transient_solver.h b/modules/linear_boltzmann_solvers/solvers/transient_solver.h
index 4eccf722..ca6e012d 100644
--- a/modules/linear_boltzmann_solvers/solvers/transient_solver.h
+++ b/modules/linear_boltzmann_solvers/solvers/transient_solver.h
@@ -4,7 +4,9 @@
 #pragma once
 
 #include "modules/solver.h"
+#include "modules/linear_boltzmann_solvers/lbs_problem/source_functions/source_flags.h"
 #include "framework/object_factory.h"
+#include <cstdint>
 #include <memory>
 #include <string>
 #include <functional>
@@ -21,7 +23,7 @@ class TransientSolver : public Solver
 public:
   explicit TransientSolver(const InputParameters& params);
 
-  ~TransientSolver() override = default;
+  ~TransientSolver() override;
 
   void Initialize() override;
   void Execute() override;
@@ -39,6 +41,10 @@ public:
 private:
   void RefreshLocalViews();
   void UpdateHasFissionableMaterial();
+  void SaveProblemStateForTransient();
+  void RestoreProblemStateFromTransient();
+  void ApplyTransientProblemState();
+  void EnsureInitializedStateIsCurrent(const std::string& caller) const;
 
   std::shared_ptr<DiscreteOrdinatesProblem> do_problem_;
   std::shared_ptr<AGSLinearSolver> ags_solver_;
@@ -53,7 +59,6 @@ private:
   /// Previous time step vectors
   std::vector<double> phi_prev_local_;
   std::vector<double> precursor_prev_local_;
-  std::vector<std::vector<double>> psi_prev_local_;
 
   /// Time discretization values and methods
   double stop_time_ = 0.1;
@@ -62,8 +67,12 @@ private:
   bool verbose_ = true;
   bool initialized_ = false;
   bool enforce_stop_time_ = false;
+  bool has_saved_problem_state_ = false;
+  bool previous_save_angular_flux_ = false;
   bool has_fissionable_material_ = false;
+  uint64_t initialized_state_epoch_ = 0;
   std::string initial_state_;
+  SetSourceFunction previous_active_set_source_function_;
   std::function<void()> pre_advance_callback_;
   std::function<void()> post_advance_callback_;
 
