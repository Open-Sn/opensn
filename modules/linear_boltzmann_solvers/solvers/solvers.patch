diff --git a/modules/linear_boltzmann_solvers/solvers/nl_keigen_solver.cc b/modules/linear_boltzmann_solvers/solvers/nl_keigen_solver.cc
index 87d68be8..347a9be6 100644
--- a/modules/linear_boltzmann_solvers/solvers/nl_keigen_solver.cc
+++ b/modules/linear_boltzmann_solvers/solvers/nl_keigen_solver.cc
@@ -8,10 +8,21 @@
 #include "framework/object_factory.h"
 #include "framework/logging/log.h"
 #include "framework/runtime.h"
+#include <cmath>
 #include <stdexcept>
 
 namespace opensn
 {
+namespace
+{
+double
+GuardedDenominator(const double value, const double eps = 1.0e-16)
+{
+  if (std::abs(value) >= eps)
+    return value;
+  return (value < 0.0) ? -eps : eps;
+}
+} // namespace
 
 OpenSnRegisterObjectInNamespace(lbs, NonLinearKEigenSolver);
 
@@ -21,7 +32,7 @@ NonLinearKEigenSolver::GetInputParameters()
   InputParameters params = Solver::GetInputParameters();
 
   params.SetGeneralDescription("Implementation of a non-linear k-Eigenvalue solver");
-  params.ChangeExistingParamToOptional("name", "PowerIterationKEigenSolver");
+  params.ChangeExistingParamToOptional("name", "NonLinearKEigenSolver");
   params.AddRequiredParameter<std::shared_ptr<Problem>>("problem", "An existing lbs problem");
 
   // Non-linear solver parameters
@@ -38,8 +49,8 @@ NonLinearKEigenSolver::GetInputParameters()
   params.AddOptionalParameter("l_gmres_restart_intvl", 30, "GMRes restart interval");
   params.AddOptionalParameter("l_gmres_breakdown_tol", 1.0e6, "GMRes breakdown tolerance");
   params.AddOptionalParameter("reset_phi0", true, "If true, reinitializes scalar fluxes to 1.0");
-  params.AddOptionalParameter("num_initial_power_iterations",
-                              0,
+  params.AddOptionalParameter<unsigned int>("num_initial_power_iterations",
+                              0u,
                               "The number of initial power iterations to execute before entering "
                               "the non-linear algorithm");
 
@@ -59,7 +70,7 @@ NonLinearKEigenSolver::NonLinearKEigenSolver(const InputParameters& params)
     nl_context_(std::make_shared<NLKEigenAGSContext>(do_problem_)),
     nl_solver_(nl_context_),
     reset_phi0_(params.GetParamValue<bool>("reset_phi0")),
-    num_initial_power_its_(params.GetParamValue<int>("num_initial_power_iterations"))
+    num_initial_power_its_(params.GetParamValue<unsigned int>("num_initial_power_iterations"))
 {
   auto& tolerances = nl_solver_.GetToleranceOptions();
 
@@ -103,13 +114,15 @@ NonLinearKEigenSolver::Execute()
   if (do_problem_->GetOptions().use_precursors)
   {
     ComputePrecursors(*do_problem_);
-    Scale(do_problem_->GetPrecursorsNewLocal(), 1.0 / nl_context_->kresid_func_context.k_eff);
+    const double keff = nl_context_->kresid_func_context.k_eff;
+    Scale(do_problem_->GetPrecursorsNewLocal(), 1.0 / GuardedDenominator(keff));
   }
 
   do_problem_->UpdateFieldFunctions();
   if (IsBalanceEnabled())
   {
-    ComputeBalance(*do_problem_, 1.0 / nl_context_->kresid_func_context.k_eff);
+    const double keff = nl_context_->kresid_func_context.k_eff;
+    ComputeBalance(*do_problem_, 1.0 / GuardedDenominator(keff));
     log.Log() << "Balance table uses k-eigenvalue normalization (production scaled by 1/k_eff)";
   }
 
diff --git a/modules/linear_boltzmann_solvers/solvers/pi_keigen_solver.cc b/modules/linear_boltzmann_solvers/solvers/pi_keigen_solver.cc
index 536fd71d..115ae51e 100644
--- a/modules/linear_boltzmann_solvers/solvers/pi_keigen_solver.cc
+++ b/modules/linear_boltzmann_solvers/solvers/pi_keigen_solver.cc
@@ -12,12 +12,31 @@
 #include "framework/runtime.h"
 #include "modules/linear_boltzmann_solvers/discrete_ordinates_problem/acceleration/discrete_ordinates_keigen_acceleration.h"
 #include "modules/linear_boltzmann_solvers/lbs_problem/iterative_methods/ags_linear_solver.h"
+#include <cmath>
 #include <iomanip>
 #include <stdexcept>
 #include "sys/stat.h"
 
 namespace opensn
 {
+namespace
+{
+LBSGroupset&
+GetFirstGroupsetOrThrow(std::vector<LBSGroupset>& groupsets)
+{
+  if (groupsets.empty())
+    throw std::invalid_argument("PowerIterationKEigenSolver requires at least one groupset.");
+  return groupsets.front();
+}
+
+double
+GuardedDenominator(const double value, const double eps = 1.0e-16)
+{
+  if (std::abs(value) >= eps)
+    return value;
+  return (value < 0.0) ? -eps : eps;
+}
+} // namespace
 
 OpenSnRegisterObjectInNamespace(lbs, PowerIterationKEigenSolver);
 
@@ -61,7 +80,7 @@ PowerIterationKEigenSolver::PowerIterationKEigenSolver(const InputParameters& pa
     phi_old_local_(do_problem_->GetPhiOldLocal()),
     phi_new_local_(do_problem_->GetPhiNewLocal()),
     groupsets_(do_problem_->GetGroupsets()),
-    front_gs_(groupsets_.front())
+    front_gs_(GetFirstGroupsetOrThrow(groupsets_))
 {
   do_problem_->SetSweepChunkMode(DiscreteOrdinatesProblem::SweepChunkMode::SteadyState);
 }
@@ -74,6 +93,8 @@ PowerIterationKEigenSolver::Initialize()
   auto& options = do_problem_->GetOptions();
   active_set_source_function_ = do_problem_->GetActiveSetSourceFunction();
   ags_solver_ = do_problem_->GetAGSSolver();
+  if (not ags_solver_)
+    throw std::runtime_error(GetName() + ": AGS solver is not available.");
 
   for (auto& wgs_solver : do_problem_->GetWGSSolvers())
   {
@@ -126,7 +147,7 @@ PowerIterationKEigenSolver::Execute()
   {
     // Set the fission source
     SetLBSFissionSource(phi_old_local_, false);
-    Scale(q_moments_local_, 1.0 / k_eff_);
+    Scale(q_moments_local_, 1.0 / GuardedDenominator(k_eff_));
 
     if (acceleration_)
       acceleration_->PrePowerIteration();
@@ -143,14 +164,15 @@ PowerIterationKEigenSolver::Execute()
     else
     {
       const auto F_new = ComputeFissionProduction(*do_problem_, phi_new_local_);
-      k_eff_ = F_new / F_prev_ * k_eff_;
+      k_eff_ = F_new / GuardedDenominator(F_prev_) * k_eff_;
       F_prev_ = F_new;
     }
 
-    const double reactivity = (k_eff_ - 1.0) / k_eff_;
+    const double reactivity = (k_eff_ - 1.0) / GuardedDenominator(k_eff_);
 
     // Check convergence, bookkeeping
-    k_eff_change = fabs(k_eff_ - k_eff_prev) / k_eff_;
+    const double k_eff_denom = std::max(std::abs(k_eff_), 1.0e-16);
+    k_eff_change = std::abs(k_eff_ - k_eff_prev) / k_eff_denom;
     k_eff_prev = k_eff_;
     nit += 1;
 
@@ -188,6 +210,7 @@ PowerIterationKEigenSolver::Execute()
   {
     auto context = wgs_solver->GetContext();
     auto wgs_context = std::dynamic_pointer_cast<WGSContext>(context);
+    OpenSnLogicalErrorIf(not wgs_context, ": Cast failed");
     total_num_sweeps += wgs_context->counter_applications_of_inv_op;
   }
 
@@ -200,13 +223,13 @@ PowerIterationKEigenSolver::Execute()
   if (options.use_precursors)
   {
     ComputePrecursors(*do_problem_);
-    Scale(do_problem_->GetPrecursorsNewLocal(), 1.0 / k_eff_);
+    Scale(do_problem_->GetPrecursorsNewLocal(), 1.0 / GuardedDenominator(k_eff_));
   }
 
   do_problem_->UpdateFieldFunctions();
   if (IsBalanceEnabled())
   {
-    ComputeBalance(*do_problem_, 1.0 / k_eff_);
+    ComputeBalance(*do_problem_, 1.0 / GuardedDenominator(k_eff_));
     log.Log() << "Balance table uses k-eigenvalue normalization (production scaled by 1/k_eff)";
   }
 
diff --git a/modules/linear_boltzmann_solvers/solvers/steady_state_solver.cc b/modules/linear_boltzmann_solvers/solvers/steady_state_solver.cc
index cf51bb70..f83ab0e2 100644
--- a/modules/linear_boltzmann_solvers/solvers/steady_state_solver.cc
+++ b/modules/linear_boltzmann_solvers/solvers/steady_state_solver.cc
@@ -63,7 +63,10 @@ SteadyStateSourceSolver::Execute()
 
   auto& options = lbs_problem_->GetOptions();
 
-  auto& ags_solver = *lbs_problem_->GetAGSSolver();
+  auto ags_solver_ptr = lbs_problem_->GetAGSSolver();
+  if (not ags_solver_ptr)
+    throw std::runtime_error(GetName() + ": AGS solver is not available.");
+  auto& ags_solver = *ags_solver_ptr;
   ags_solver.Solve();
 
   if (options.restart_writes_enabled)
diff --git a/modules/linear_boltzmann_solvers/solvers/transient_solver.cc b/modules/linear_boltzmann_solvers/solvers/transient_solver.cc
index 26d13d32..23ff535b 100644
--- a/modules/linear_boltzmann_solvers/solvers/transient_solver.cc
+++ b/modules/linear_boltzmann_solvers/solvers/transient_solver.cc
@@ -12,10 +12,24 @@
 #include "framework/runtime.h"
 #include <iomanip>
 #include <limits>
+#include <stdexcept>
 #include <utility>
 
 namespace opensn
 {
+namespace
+{
+TransientSolver::InitialState
+ParseInitialStateOrThrow(const std::string& value)
+{
+  if (value == "existing")
+    return TransientSolver::InitialState::EXISTING;
+  if (value == "zero")
+    return TransientSolver::InitialState::ZERO;
+  throw std::invalid_argument("TransientSolver: invalid initial_state '" + value + "'");
+}
+} // namespace
+
 OpenSnRegisterObjectInNamespace(lbs, TransientSolver);
 
 InputParameters
@@ -44,12 +58,14 @@ TransientSolver::GetInputParameters()
 void
 TransientSolver::SetTimeStep(double dt)
 {
+  OpenSnInvalidArgumentIf(dt <= 0.0, GetName() + ": dt must be positive.");
   do_problem_->SetTimeStep(dt);
 }
 
 void
 TransientSolver::SetTheta(double theta)
 {
+  OpenSnInvalidArgumentIf(theta <= 0.0 or theta > 1.0, GetName() + ": theta must be in (0, 1].");
   do_problem_->SetTheta(theta);
 }
 
@@ -66,7 +82,7 @@ TransientSolver::TransientSolver(const InputParameters& params)
 {
   stop_time_ = params.GetParamValue<double>("stop_time");
   verbose_ = params.GetParamValue<bool>("verbose");
-  initial_state_ = params.GetParamValue<std::string>("initial_state");
+  initial_state_ = ParseInitialStateOrThrow(params.GetParamValue<std::string>("initial_state"));
   do_problem_->SetTimeStep(params.GetParamValue<double>("dt"));
   do_problem_->SetTheta(params.GetParamValue<double>("theta"));
 }
@@ -74,11 +90,18 @@ TransientSolver::TransientSolver(const InputParameters& params)
 void
 TransientSolver::RefreshLocalViews()
 {
+  if (not do_problem_)
+    throw std::runtime_error(GetName() + ": Problem is not set.");
+
   q_moments_local_ = &do_problem_->GetQMomentsLocal();
   phi_old_local_ = &do_problem_->GetPhiOldLocal();
   phi_new_local_ = &do_problem_->GetPhiNewLocal();
   precursor_new_local_ = &do_problem_->GetPrecursorsNewLocal();
   psi_new_local_ = &do_problem_->GetPsiNewLocal();
+
+  if (not q_moments_local_ or not phi_old_local_ or not phi_new_local_ or not precursor_new_local_ or
+      not psi_new_local_)
+    throw std::runtime_error(GetName() + ": Failed to refresh local data views.");
 }
 
 void
@@ -100,19 +123,20 @@ TransientSolver::Initialize()
   options.save_angular_flux = true;
   do_problem_->SetTime(current_time_);
 
-  const std::string& init_state = initial_state_;
   RefreshLocalViews();
   if (not phi_new_local_ or phi_new_local_->empty())
   {
-    if (init_state != "zero")
+    if (initial_state_ != InitialState::ZERO)
       throw std::runtime_error(GetName() + ": Problem must be initialized before TransientSolver.");
     do_problem_->Initialize();
     RefreshLocalViews();
   }
   if (not phi_new_local_ or phi_new_local_->empty())
     throw std::runtime_error(GetName() + ": Problem initialization failed.");
+  if (phi_old_local_->size() != phi_new_local_->size())
+    throw std::runtime_error(GetName() + ": phi_old and phi_new vectors are inconsistent.");
 
-  if (init_state == "zero")
+  if (initial_state_ == InitialState::ZERO)
   {
     std::fill(phi_new_local_->begin(), phi_new_local_->end(), 0.0);
     std::fill(phi_old_local_->begin(), phi_old_local_->end(), 0.0);
@@ -138,6 +162,8 @@ TransientSolver::Initialize()
   do_problem_->ReinitializeSolverSchemes();
   RefreshLocalViews();
   ags_solver_ = do_problem_->GetAGSSolver();
+  if (not ags_solver_)
+    throw std::runtime_error(GetName() + ": AGS solver not available.");
   UpdateHasFissionableMaterial();
   if (options.use_precursors and not has_fissionable_material_)
     log.Log0Warning() << GetName()
@@ -171,7 +197,6 @@ TransientSolver::Initialize()
   // Sync with the current solution
   phi_prev_local_ = *phi_new_local_;
   precursor_prev_local_ = *precursor_new_local_;
-  psi_prev_local_ = *psi_new_local_;
 
   initialized_ = true;
 }
@@ -279,13 +304,6 @@ TransientSolver::Advance()
 
   // Solve
   *phi_old_local_ = phi_prev_local_;
-  {
-    auto current_solver = do_problem_->GetAGSSolver();
-    if (current_solver.get() != ags_solver_.get())
-      ags_solver_ = std::move(current_solver);
-  }
-  if (not ags_solver_)
-    throw std::runtime_error(GetName() + ": AGS solver not available.");
   ags_solver_->Solve();
 
   // For non-fission source-only problems, match TimeDependentSourceSolver behavior.
@@ -312,7 +330,6 @@ TransientSolver::Advance()
   current_time_ += dt;
   do_problem_->SetTime(current_time_);
   phi_prev_local_ = *phi_new_local_;
-  psi_prev_local_ = *psi_new_local_;
   do_problem_->UpdateFieldFunctions();
   do_problem_->UpdatePsiOld();
   if (options.use_precursors)
@@ -333,6 +350,8 @@ TransientSolver::StepPrecursors()
   {
     const auto& fe_values = do_problem_->GetUnitCellMatrices()[cell.local_id];
     const double cell_volume = transport_views[cell.local_id].GetVolume();
+    if (cell_volume <= 0.0)
+      throw std::runtime_error(GetName() + ": Non-positive cell volume encountered.");
     const auto& xs = do_problem_->GetBlockID2XSMap().at(cell.block_id);
     const auto& precursors = xs->GetPrecursors();
     const auto& nu_delayed_sigma_f = xs->GetNuDelayedSigmaF();
diff --git a/modules/linear_boltzmann_solvers/solvers/transient_solver.h b/modules/linear_boltzmann_solvers/solvers/transient_solver.h
index 4eccf722..d40a13d9 100644
--- a/modules/linear_boltzmann_solvers/solvers/transient_solver.h
+++ b/modules/linear_boltzmann_solvers/solvers/transient_solver.h
@@ -19,6 +19,12 @@ class AGSLinearSolver;
 class TransientSolver : public Solver
 {
 public:
+  enum class InitialState
+  {
+    EXISTING,
+    ZERO
+  };
+
   explicit TransientSolver(const InputParameters& params);
 
   ~TransientSolver() override = default;
@@ -53,7 +59,6 @@ private:
   /// Previous time step vectors
   std::vector<double> phi_prev_local_;
   std::vector<double> precursor_prev_local_;
-  std::vector<std::vector<double>> psi_prev_local_;
 
   /// Time discretization values and methods
   double stop_time_ = 0.1;
@@ -63,7 +68,7 @@ private:
   bool initialized_ = false;
   bool enforce_stop_time_ = false;
   bool has_fissionable_material_ = false;
-  std::string initial_state_;
+  InitialState initial_state_ = InitialState::EXISTING;
   std::function<void()> pre_advance_callback_;
   std::function<void()> post_advance_callback_;
 
