
.. _program_listing_file_modules_linear_boltzmann_solvers_discrete_ordinates_problem_sweep_chunks_sweep_chunk.h:

Program Listing for File sweep_chunk.h
======================================

|exhale_lsh| :ref:`Return to documentation for file <file_modules_linear_boltzmann_solvers_discrete_ordinates_problem_sweep_chunks_sweep_chunk.h>` (``modules/linear_boltzmann_solvers/discrete_ordinates_problem/sweep_chunks/sweep_chunk.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   // SPDX-FileCopyrightText: 2024 The OpenSn Authors <https://open-sn.github.io/opensn/>
   // SPDX-License-Identifier: MIT
   
   #pragma once
   
   #include "framework/math/spatial_discretization/finite_element/unit_cell_matrices.h"
   #include "modules/linear_boltzmann_solvers/discrete_ordinates_problem/sweep/angle_aggregation/angle_aggregation.h"
   #include "modules/linear_boltzmann_solvers/lbs_problem/groupset/lbs_groupset.h"
   #include "modules/linear_boltzmann_solvers/lbs_problem/lbs_structs.h"
   #include <functional>
   
   namespace opensn
   {
   
   /// Sweep work function
   class SweepChunk
   {
   public:
     /// Convenient typdef for the moment call back function. See moment_callbacks.
     using MomentCallbackFunc = std::function<void(SweepChunk* sweeper, AngleSet* angle_set)>;
   
     /**
      * Functions of type MomentCallbackFunc can be added to the moment_callbacks
      * vector and these can be called from within functions taking a
      * LBSGroupset instance. The intention is that this function can
      * be used as a general interface to retrieve angular flux values
      */
     std::vector<MomentCallbackFunc> moment_callbacks;
   
     SweepChunk(std::vector<double>& destination_phi,
                std::vector<double>& destination_psi,
                const std::shared_ptr<MeshContinuum>& grid,
                const SpatialDiscretization& discretization,
                const std::vector<UnitCellMatrices>& unit_cell_matrices,
                std::vector<CellLBSView>& cell_transport_views,
                const std::vector<double>& densities,
                const std::vector<double>& source_moments,
                const LBSGroupset& groupset,
                const std::map<int, std::shared_ptr<MultiGroupXS>>& xs,
                int num_moments,
                int max_num_cell_dofs,
                int min_num_cell_dofs)
       : grid_(grid),
         discretization_(discretization),
         unit_cell_matrices_(unit_cell_matrices),
         cell_transport_views_(cell_transport_views),
         densities_(densities),
         source_moments_(source_moments),
         groupset_(groupset),
         xs_(xs),
         num_moments_(num_moments),
         max_num_cell_dofs_(max_num_cell_dofs),
         min_num_cell_dofs_(min_num_cell_dofs),
         save_angular_flux_(not destination_psi.empty()),
         groupset_angle_group_stride_(groupset_.psi_uk_man_.GetNumberOfUnknowns() *
                                      groupset_.groups.size()),
         groupset_group_stride_(groupset_.groups.size()),
         destination_phi_(destination_phi),
         destination_psi_(destination_psi)
     {
     }
   
     /// Sweep chunks should override this.
     virtual void Sweep(AngleSet& angle_set) {}
   
     /// Sets the currently active angleset.
     virtual void SetAngleSet(AngleSet& angle_set) {}
   
     /// For cell-by-cell methods or computing the residual on a single cell.
     virtual void SetCell(Cell const* cell_ptr, AngleSet& angle_set) {}
   
     virtual ~SweepChunk() = default;
   
     /**
      * Zero the portion of the output flux moments vector corresponding to the groupset for this
      * sweep chunk.
      */
     void ZeroDestinationPhi();
   
     /// Sets all elements of the output angular flux vector to zero.
     void ZeroDestinationPsi() { (destination_psi_).assign((destination_psi_).size(), 0.0); }
   
     /// Activates or deactives the surface src flag.
     void SetBoundarySourceActiveFlag(bool flag_value) { surface_source_active_ = flag_value; }
   
     /// Returns the surface src-active flag.
     bool IsSurfaceSourceActive() const { return surface_source_active_; }
   
   protected:
     const std::shared_ptr<MeshContinuum> grid_;
     const SpatialDiscretization& discretization_;
     const std::vector<UnitCellMatrices>& unit_cell_matrices_;
     std::vector<CellLBSView>& cell_transport_views_;
     const std::vector<double>& densities_;
     const std::vector<double>& source_moments_;
     const LBSGroupset& groupset_;
     const std::map<int, std::shared_ptr<MultiGroupXS>>& xs_;
     const int num_moments_;
     const int max_num_cell_dofs_;
     const int min_num_cell_dofs_;
     const bool save_angular_flux_;
     const size_t groupset_angle_group_stride_;
     const size_t groupset_group_stride_;
     std::vector<double>& destination_phi_;
     std::vector<double>& destination_psi_;
     bool surface_source_active_ = false;
   };
   
   } // namespace opensn
