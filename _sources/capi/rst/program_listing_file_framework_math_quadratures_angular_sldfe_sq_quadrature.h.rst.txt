
.. _program_listing_file_framework_math_quadratures_angular_sldfe_sq_quadrature.h:

Program Listing for File sldfe_sq_quadrature.h
==============================================

|exhale_lsh| :ref:`Return to documentation for file <file_framework_math_quadratures_angular_sldfe_sq_quadrature.h>` (``framework/math/quadratures/angular/sldfe_sq_quadrature.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   // SPDX-FileCopyrightText: 2024 The OpenSn Authors <https://open-sn.github.io/opensn/>
   // SPDX-License-Identifier: MIT
   
   #pragma once
   
   #include "framework/math/quadratures/angular/angular_quadrature.h"
   #include "framework/math/quadratures/gausslegendre_quadrature.h"
   #include "framework/data_types/dense_matrix.h"
   #include "framework/data_types/matrix3x3.h"
   #include "framework/data_types/vector.h"
   #include "framework/math/math.h"
   #include <array>
   #include <vector>
   
   namespace opensn
   {
   
   class SLDFEsqQuadrature : public AngularQuadrature
   {
   protected:
     enum class QuadraturePointOptimization
     {
       CENTROID,
       EMPIRICAL,
       ISOLATED
     };
   
     struct SphericalQuadrilateral
     {
       std::array<Vector3, 4> vertices_xy_tilde;
       std::array<Vector3, 4> vertices_xyz_prime;
       std::array<Vector3, 4> vertices_xyz;
       Vector3 centroid_xyz;
   
       Matrix3x3 rotation_matrix;
       Vector3 translation_vector;
   
       std::array<Vector3, 4> sub_sqr_points;
       std::array<double, 4> sub_sqr_weights{};
   
       double area = 0.0;
       Vector3 octant_modifier;
     };
   
   public:
     SLDFEsqQuadrature(int level, unsigned int dimension, unsigned int scattering_order);
   
     ~SLDFEsqQuadrature() override = default;
   
     void TestIntegration(int test_case, double ref_solution, int RiemannN = 0);
   
     void PrintQuadratureToFile(const std::string& file_base);
   
     void LocallyRefine(const Vector3& ref_dir, double cone_size, bool dir_as_plane_normal = false);
   
   protected:
     void GenerateRefinement();
   
     void PopulateQuadratureAbscissae();
   
     virtual bool FilterQuadraturePoint(const Vector3& omega) const;
   
     QuadraturePointOptimization qp_optimization_type = QuadraturePointOptimization::EMPIRICAL;
     std::vector<SphericalQuadrilateral> deployed_SQs;
   
   private:
     struct BaseFunctor
     {
       virtual double operator()(double mu, double eta, double xi) { return 0.0; }
       virtual ~BaseFunctor() = default;
     };
   
     struct FunctionWeightFromRho
     {
       SLDFEsqQuadrature& quad;
       Vector3& centroid_xy_tilde;
       std::array<Vector3, 4>& radii_vectors_xy_tilde;
       SphericalQuadrilateral& sq;
   
       std::array<Vector<double>, 4> rhs;
       DenseMatrix<double> A;
       DenseMatrix<double> A_inv;
       std::array<Vector<double>, 4> c_coeffs;
       std::vector<Vector3>& lqp;
       std::vector<double>& lqw;
   
       FunctionWeightFromRho(SLDFEsqQuadrature& quad,
                             Vector3& centroid_xy_tilde,
                             std::array<Vector3, 4>& radii_vectors_xy_tilde,
                             SphericalQuadrilateral& sq,
                             GaussLegendreQuadrature& legendre_quadrature)
         : quad(quad),
           centroid_xy_tilde(centroid_xy_tilde),
           radii_vectors_xy_tilde(radii_vectors_xy_tilde),
           sq(sq),
           A(4, 4),
           A_inv(4, 4),
           lqp(legendre_quadrature.qpoints),
           lqw(legendre_quadrature.weights)
       {
         for (int i = 0; i < 4; ++i)
         {
           rhs[i] = Vector<double>(4, 0.0);
           c_coeffs[i] = Vector<double>(4, 0.0);
           rhs[i](i) = 1.0;
         }
       }
   
       std::array<double, 4> operator()(const Vector<double>& rho)
       {
         std::array<Vector3, 4> qpoints;
         for (int i = 0; i < 4; ++i)
         {
           auto xy_tilde = centroid_xy_tilde + rho(i) * radii_vectors_xy_tilde[i];
           auto xyz_prime = sq.rotation_matrix * xy_tilde + sq.translation_vector;
           qpoints[i] = xyz_prime.Normalized();
         }
   
         for (int i = 0; i < 4; ++i)
           A.SetRow(i, Vector<double>({1.0, qpoints[i][0], qpoints[i][1], qpoints[i][2]}));
   
         A_inv = Inverse(A);
   
         for (int i = 0; i < 4; ++i)
           c_coeffs[i] = Mult(A_inv, rhs[i]);
   
         return SLDFEsqQuadrature::IntegrateLDFEShapeFunctions(sq, c_coeffs, lqp, lqw);
       }
     };
   
     static constexpr double a_ = 0.57735026919;
     double raw_weight_sum_ = 0.0;
     int level_ = 0;
     std::vector<Vector3> diagonal_vertices_;
     std::vector<SphericalQuadrilateral> initial_octant_SQs_;
   
     void GenerateDiagonalSpacings();
   
     void GenerateReferenceFaceVertices(const Matrix3x3& rotation_matrix, const Vector3& translation);
   
     void DevelopSQLDFEValues(SphericalQuadrilateral& sq, GaussLegendreQuadrature& legendre);
   
     void EmpiricalQPOptimization(SphericalQuadrilateral& sq,
                                  GaussLegendreQuadrature& legendre,
                                  Vector3& sq_xy_tilde_centroid,
                                  std::array<Vector3, 4>& radii_vectors_xy_tilde,
                                  std::array<double, 4>& sub_sub_sqr_areas);
   
     void IsolatedQPOptimization(SphericalQuadrilateral& sq,
                                 GaussLegendreQuadrature& legendre,
                                 Vector3& sq_xy_tilde_centroid,
                                 std::array<Vector3, 4>& radii_vectors_xy_tilde,
                                 std::array<double, 4>& sub_sub_sqr_areas);
   
     static double ComputeSphericalQuadrilateralArea(std::array<Vector3, 4>& vertices_xyz);
   
     static std::array<double, 4>
     IntegrateLDFEShapeFunctions(const SphericalQuadrilateral& sq,
                                 std::array<Vector<double>, 4>& shape_coeffs,
                                 const std::vector<Vector3>& legendre_qpoints,
                                 const std::vector<double>& legendre_qweights);
   
     void CopyToAllOctants();
   
     static std::array<std::array<Vector3, 4>, 4>
     BuildSubSquares(const std::array<Vector3, 4>& vertices_xy_tilde, const Vector3& centroid);
   
     double RiemannIntegral(struct BaseFunctor* F, int Ni = 20000);
   
     double QuadratureSSIntegral(struct BaseFunctor* F);
   
     std::array<SphericalQuadrilateral, 4> SplitSQ(SphericalQuadrilateral& sq,
                                                   GaussLegendreQuadrature& legendre);
   };
   
   class SLDFEsqQuadrature3DXYZ : public SLDFEsqQuadrature
   {
   public:
     SLDFEsqQuadrature3DXYZ(int level, unsigned int scattering_order);
   
     ~SLDFEsqQuadrature3DXYZ() override = default;
   };
   
   class SLDFEsqQuadrature2DXY : public SLDFEsqQuadrature
   {
   public:
     SLDFEsqQuadrature2DXY(int level, unsigned int scattering_order);
   
     ~SLDFEsqQuadrature2DXY() override = default;
   
   protected:
     bool FilterQuadraturePoint(const Vector3& omega) const override;
   };
   
   } // namespace opensn
