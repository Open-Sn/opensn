
.. _program_listing_file_modules_linear_boltzmann_solvers_discrete_ordinates_problem_sweep_boundary_reflecting_boundary.h:

Program Listing for File reflecting_boundary.h
==============================================

|exhale_lsh| :ref:`Return to documentation for file <file_modules_linear_boltzmann_solvers_discrete_ordinates_problem_sweep_boundary_reflecting_boundary.h>` (``modules/linear_boltzmann_solvers/discrete_ordinates_problem/sweep/boundary/reflecting_boundary.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   // SPDX-FileCopyrightText: 2024 The OpenSn Authors <https://open-sn.github.io/opensn/>
   // SPDX-License-Identifier: MIT
   
   #pragma once
   
   #include "modules/linear_boltzmann_solvers/discrete_ordinates_problem/sweep/boundary/sweep_boundary.h"
   #include <vector>
   #include <limits>
   
   namespace opensn
   {
   
   /// Reflective boundary condition.
   class ReflectingBoundary : public SweepBoundary
   {
   protected:
     const Vector3 normal_;
     bool opposing_reflected_ = false;
   
     // Populated by angle aggregation
     // AngularFluxData indices are: angle, cell per angle, faces per cell, DOFs per face, groups per
     // DOF
     using AngularFluxData = std::vector<std::vector<std::vector<std::vector<std::vector<double>>>>>;
     AngularFluxData boundary_flux_;
     AngularFluxData boundary_flux_old_;
   
     std::vector<int> reflected_anglenum_;
     std::vector<bool> angle_readyflags_;
   
   public:
     ReflectingBoundary(size_t num_groups,
                        const Vector3& normal,
                        CoordinateSystemType coord_type = CoordinateSystemType::CARTESIAN)
       : SweepBoundary(LBSBoundaryType::REFLECTING, num_groups, coord_type), normal_(normal)
     {
     }
   
     const Vector3& GetNormal() const { return normal_; }
   
     const Vector3* GetNormalForReflection() const override { return &normal_; }
   
     bool HasDelayedAngularFlux() const override { return true; }
   
     void InitializeDelayedAngularFlux(const std::shared_ptr<MeshContinuum>& grid,
                                       const AngularQuadrature& quadrature) override;
   
     void FinalizeDelayedAngularFluxSetup(
       uint64_t boundary_id,
       const std::map<uint64_t, std::shared_ptr<SweepBoundary>>& boundaries) override;
   
     void ZeroOpposingDelayedAngularFluxOld() override;
   
     size_t CountDelayedAngularDOFsNew() const override;
   
     size_t CountDelayedAngularDOFsOld() const override;
   
     void AppendNewDelayedAngularDOFsToVector(std::vector<double>& output) const override;
   
     void AppendOldDelayedAngularDOFsToVector(std::vector<double>& output) const override;
   
     void AppendNewDelayedAngularDOFsToArray(int64_t& index, double* buffer) const override;
   
     void AppendOldDelayedAngularDOFsToArray(int64_t& index, double* buffer) const override;
   
     void SetNewDelayedAngularDOFsFromArray(int64_t& index, const double* buffer) override;
   
     void SetOldDelayedAngularDOFsFromArray(int64_t& index, const double* buffer) override;
   
     void SetNewDelayedAngularDOFsFromVector(const std::vector<double>& values,
                                             size_t& index) override;
   
     void SetOldDelayedAngularDOFsFromVector(const std::vector<double>& values,
                                             size_t& index) override;
   
     void CopyDelayedAngularFluxOldToNew() override;
   
     void CopyDelayedAngularFluxNewToOld() override;
   
     double* PsiIncoming(uint64_t cell_local_id,
                         unsigned int face_num,
                         unsigned int fi,
                         unsigned int angle_num,
                         int group_num) override;
   
     double* PsiOutgoing(uint64_t cell_local_id,
                         unsigned int face_num,
                         unsigned int fi,
                         unsigned int angle_num) override;
   
     void UpdateAnglesReadyStatus(const std::vector<std::uint32_t>& angles) override;
   
     bool CheckAnglesReadyStatus(const std::vector<std::uint32_t>& angles) override;
   
     void ResetAnglesReadyStatus() override;
   
   private:
     static constexpr double epsilon_ = 1.0e-8;
   
   private:
     template <typename Fn>
     void ForEachDelayedAngularFlux(bool use_old_store, Fn&& fn);
   
     template <typename Fn>
     void ForEachDelayedAngularFluxConst(bool use_old_store, Fn&& fn) const;
   };
   
   } // namespace opensn
