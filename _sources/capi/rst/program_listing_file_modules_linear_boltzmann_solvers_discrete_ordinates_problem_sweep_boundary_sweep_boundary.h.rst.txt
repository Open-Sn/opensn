
.. _program_listing_file_modules_linear_boltzmann_solvers_discrete_ordinates_problem_sweep_boundary_sweep_boundary.h:

Program Listing for File sweep_boundary.h
=========================================

|exhale_lsh| :ref:`Return to documentation for file <file_modules_linear_boltzmann_solvers_discrete_ordinates_problem_sweep_boundary_sweep_boundary.h>` (``modules/linear_boltzmann_solvers/discrete_ordinates_problem/sweep/boundary/sweep_boundary.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   // SPDX-FileCopyrightText: 2024 The OpenSn Authors <https://open-sn.github.io/opensn/>
   // SPDX-License-Identifier: MIT
   
   #pragma once
   
   #include "modules/linear_boltzmann_solvers/lbs_problem/lbs_structs.h"
   #include <map>
   #include <memory>
   #include <vector>
   
   namespace opensn
   {
   
   class MeshContinuum;
   
   /// Base class for sweep related boundaries.
   class SweepBoundary
   {
   public:
     explicit SweepBoundary(LBSBoundaryType bndry_type,
                            size_t num_groups,
                            CoordinateSystemType coord_type)
       : num_groups_(num_groups), type_(bndry_type), coord_type_(coord_type)
     {
       zero_boundary_flux_.resize(num_groups_, 0.0);
     }
   
     virtual ~SweepBoundary() = default;
   
     LBSBoundaryType GetType() const { return type_; }
   
     CoordinateSystemType GetCoordType() const { return coord_type_; }
   
     bool IsReflecting() const { return type_ == LBSBoundaryType::REFLECTING; }
   
     double GetEvaluationTime() const { return evaluation_time_; }
   
     void SetEvaluationTime(double time) { evaluation_time_ = time; }
   
     virtual bool HasDelayedAngularFlux() const { return false; }
   
     virtual void InitializeDelayedAngularFlux(const std::shared_ptr<MeshContinuum>& grid,
                                               const AngularQuadrature& quadrature)
     {
     }
   
     virtual void FinalizeDelayedAngularFluxSetup(
       uint64_t boundary_id, const std::map<uint64_t, std::shared_ptr<SweepBoundary>>& boundaries)
     {
     }
   
     virtual void ZeroOpposingDelayedAngularFluxOld() {}
   
     virtual size_t CountDelayedAngularDOFsNew() const { return 0; }
   
     virtual size_t CountDelayedAngularDOFsOld() const { return 0; }
   
     virtual void AppendNewDelayedAngularDOFsToVector(std::vector<double>& output) const {}
   
     virtual void AppendOldDelayedAngularDOFsToVector(std::vector<double>& output) const {}
   
     virtual void AppendNewDelayedAngularDOFsToArray(int64_t& index, double* buffer) const {}
   
     virtual void AppendOldDelayedAngularDOFsToArray(int64_t& index, double* buffer) const {}
   
     virtual void SetNewDelayedAngularDOFsFromArray(int64_t& index, const double* buffer) {}
   
     virtual void SetOldDelayedAngularDOFsFromArray(int64_t& index, const double* buffer) {}
   
     virtual void SetNewDelayedAngularDOFsFromVector(const std::vector<double>& values, size_t& index)
     {
     }
   
     virtual void SetOldDelayedAngularDOFsFromVector(const std::vector<double>& values, size_t& index)
     {
     }
   
     virtual void CopyDelayedAngularFluxOldToNew() {}
   
     virtual void CopyDelayedAngularFluxNewToOld() {}
   
     virtual void ResetAnglesReadyStatus() {}
   
     virtual const Vector3* GetNormalForReflection() const { return nullptr; }
   
     /// Returns a pointer to the location of the incoming flux.
     virtual double* PsiIncoming(uint64_t cell_local_id,
                                 unsigned int face_num,
                                 unsigned int fi,
                                 unsigned int angle_num,
                                 int group_num);
   
     /// Returns a pointer to the location of the outgoing flux.
     virtual double* PsiOutgoing(uint64_t cell_local_id,
                                 unsigned int face_num,
                                 unsigned int fi,
                                 unsigned int angle_num);
   
     virtual void UpdateAnglesReadyStatus(const std::vector<std::uint32_t>& angles) {}
   
     virtual bool CheckAnglesReadyStatus(const std::vector<std::uint32_t>& angles) { return true; }
   
     virtual void Setup(const std::shared_ptr<MeshContinuum>& grid,
                        const AngularQuadrature& quadrature)
     {
     }
   
     double* ZeroFlux(int group_num) { return &zero_boundary_flux_[group_num]; }
   
   protected:
     std::vector<double> zero_boundary_flux_;
     size_t num_groups_;
   
   private:
     const LBSBoundaryType type_;
     const CoordinateSystemType coord_type_;
     /// Time value passed to boundary functions
     double evaluation_time_ = 0.0;
   };
   
   /**
    * This boundary function class can be derived from to
    * provide a much more custom experience. This function
    * is called during Setup.
    */
   class BoundaryFunction
   {
   public:
     /// Customized boundary function by calling an input routine.
     virtual std::vector<double>
     Evaluate(size_t cell_global_id,
              int cell_block_id,
              unsigned int face_index,
              unsigned int face_node_index,
              const Vector3& face_node_location,
              const Vector3& face_node_normal,
              const std::vector<int>& quadrature_angle_indices,
              const std::vector<Vector3>& quadrature_angle_vectors,
              const std::vector<std::pair<double, double>>& quadrature_phi_theta_angles,
              const std::vector<int>& group_indices,
              double time) = 0;
   
     virtual ~BoundaryFunction() = default;
   };
   
   } // namespace opensn
