

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3.1. A First Example &mdash; OpenSn  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Coding Standards" href="../../../coding_standard.html" />
    <link rel="prev" title="3. Linear Boltzmann Solver" href="../index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            OpenSn
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Quick Install Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../theory/index.html">Theory Manual</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Tutorials</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../meshing/index.html">1. Meshing and Partitioning</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../material/index.html">2. Material and Source Definitions</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../index.html">3. Linear Boltzmann Solver</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">3.1. A First Example</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#check-the-number-of-processes">3.1.1. Check the number of processes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#mesh">3.1.2. Mesh</a></li>
<li class="toctree-l4"><a class="reference internal" href="#materials">3.1.3. Materials</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cross-sections">3.1.4. Cross Sections</a></li>
<li class="toctree-l4"><a class="reference internal" href="#volumetric-source">3.1.5. Volumetric Source</a></li>
<li class="toctree-l4"><a class="reference internal" href="#angular-quadrature">3.1.6. Angular Quadrature</a></li>
<li class="toctree-l4"><a class="reference internal" href="#linear-boltzmann-solver">3.1.7. Linear Boltzmann Solver</a></li>
<li class="toctree-l4"><a class="reference internal" href="#post-processing-via-field-functions">3.1.8. Post-Processing via Field Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#possible-extensions">3.1.9. Possible Extensions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-complete-input-is-below">3.1.10. The complete input is below:</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../coding_standard.html">Coding Standards</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../workflow.html">Developer Workflow</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">OpenSn</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Tutorials</a></li>
          <li class="breadcrumb-item"><a href="../index.html"><span class="section-number">3. </span>Linear Boltzmann Solver</a></li>
      <li class="breadcrumb-item active"><span class="section-number">3.1. </span>A First Example</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="a-first-example">
<h1><span class="section-number">3.1. </span>A First Example<a class="headerlink" href="#a-first-example" title="Link to this heading"></a></h1>
<p>This is a complete simulation transport example. Each aspect of the simulation process is kept to a minimum:</p>
<ul class="simple">
<li><p>We use an orthogonal 2D grid;</p></li>
<li><p>We introduce the concept of domain decomposition (“partitioning”);</p></li>
<li><p>The domain is homogeneous (single material, uniform isotropic external source), vacuum boundary conditions apply;</p></li>
<li><p>The cross sections are given in a text file (with our OpenSn format); we use only one energy group in this example;</p></li>
<li><p>The angular quadrature (discretization in angle) is introduced;</p></li>
<li><p>The Linear Boltzmann Solver (LBS) options are keep to a minimum.</p></li>
</ul>
<p>Because transport simulations are computationally expensive due to the high dimensional of the phase-space
(physical space, energy, direction), they are often performed using several parallel processes (e.g., CPU cores).
In what follows, we enforce that this first example be run with 4 MPI processes.</p>
<hr class="docutils" />
<section id="check-the-number-of-processes">
<h2><span class="section-number">3.1.1. </span>Check the number of processes<a class="headerlink" href="#check-the-number-of-processes" title="Link to this heading"></a></h2>
<p>This portion of the lua input is not mandatory. The user is free to delete it and run the code with a different number
of processes. However, to reproduce the graphics below, one needs to run with 4 MPI ranks.</p>
<p>The lua input performs this following checks:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">check_num_procs==nil</span></code> will be true when running serially without MPI</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">number_of_processes</span> <span class="pre">~=</span> <span class="pre">num_procs</span></code> will be true when the number of MPI processes requested is not equal to the preset value of <code class="docutils literal notranslate"><span class="pre">4</span></code>.</p></li>
</ul>
<p>To run the code, simply type: <code class="docutils literal notranslate"><span class="pre">mpiexec</span> <span class="pre">-n</span> <span class="pre">4</span> <span class="pre">path/to/opensn</span> <span class="pre">-i</span> <span class="pre">input_filename.lua</span></code></p>
<p>For more runtime options, type <code class="docutils literal notranslate"><span class="pre">path/to/opensn</span> <span class="pre">-h</span></code> for help.</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Check num_procs</span>
<span class="nv">num_procs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span>
<span class="kr">if</span><span class="w"> </span><span class="nv">check_num_procs</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="nv">number_of_processes</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="nv">num_procs</span><span class="w"> </span><span class="kr">then</span>
<span class="w">  </span><span class="nf">Log</span><span class="p">(</span>
<span class="w">    </span><span class="nv">LOG_0ERROR</span><span class="p">,</span>
<span class="w">    </span><span class="s2">&quot;Incorrect amount of processors. &quot;</span>
<span class="w">      </span><span class="o">..</span><span class="w"> </span><span class="s2">&quot;Expected &quot;</span>
<span class="w">      </span><span class="o">..</span><span class="w"> </span><span class="nb">tostring</span><span class="p">(</span><span class="nv">num_procs</span><span class="p">)</span>
<span class="w">      </span><span class="o">..</span><span class="w"> </span><span class="s2">&quot;. Pass check_num_procs=false to override if possible.&quot;</span>
<span class="w">  </span><span class="p">)</span>
<span class="w">  </span><span class="nb">os.exit</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
<span class="kr">end</span>
</pre></div>
</div>
</section>
<section id="mesh">
<h2><span class="section-number">3.1.2. </span>Mesh<a class="headerlink" href="#mesh" title="Link to this heading"></a></h2>
<p>Here, we will use the in-house orthogonal mesh generator for a simple Cartesian grid.</p>
<section id="list-of-nodes">
<h3><span class="section-number">3.1.2.1. </span>List of nodes<a class="headerlink" href="#list-of-nodes" title="Link to this heading"></a></h3>
<p>We first create a lua table for the list of nodes. The nodes will be spread from -1 to +1.
Be mindful that lua indexing starts at 1.</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Setup the mesh</span>
<span class="nv">nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span>
<span class="nv">n_cells</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span>
<span class="nv">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.</span>
<span class="nv">xmin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="nv">length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.</span>
<span class="nv">dx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nv">n_cells</span>
<span class="kr">for</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nv">n_cells</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="kr">do</span>
<span class="w">  </span><span class="nv">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="nv">nodes</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">xmin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">k</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nv">dx</span>
<span class="kr">end</span>
</pre></div>
</div>
</section>
<section id="orthogonal-mesh-generation">
<h3><span class="section-number">3.1.2.2. </span>Orthogonal Mesh Generation<a class="headerlink" href="#orthogonal-mesh-generation" title="Link to this heading"></a></h3>
<p>We use the <code class="docutils literal notranslate"><span class="pre">OrthogonalMeshGenerator</span></code> and pass the list of nodes per dimension. Here, we pass 2 times the same list of
nodes to create a 2D geometry with square cells. Thus, we create a square domain, of side length 2, centered on the origin (0,0).</p>
<p>We also partition the 2D mesh into 2x2 subdomains using <code class="docutils literal notranslate"><span class="pre">KBAGraphPartitioner</span></code>. Since we want the split the x-axis in 2,
we give only 1 value in the xcuts array (x=0). Likewise for ycuts (y=0). The assignment to a partition is done based on where the
cell center is located with respect to the various xcuts, ycuts, and zcuts (a fuzzy logic is applied to avoid issues).</p>
<p>The resulting mesh and partition is shown below:</p>
<p><img alt="Mesh_Partition" src="../../../_images/first_example_mesh_partition.png" /></p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="nv">meshgen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">mesh</span><span class="p">.</span><span class="py">OrthogonalMeshGenerator</span><span class="p">.</span><span class="nf">Create</span><span class="p">({</span>
<span class="w">  </span><span class="nv">node_sets</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nv">nodes</span><span class="p">,</span><span class="w"> </span><span class="nv">nodes</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="nv">partitioner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">mesh</span><span class="p">.</span><span class="py">KBAGraphPartitioner</span><span class="p">.</span><span class="nf">Create</span><span class="p">({</span>
<span class="w">    </span><span class="nv">nx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="nv">ny</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="nv">xcuts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="nv">ycuts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">}),</span>
<span class="p">})</span>
<span class="nv">meshgen</span><span class="p">:</span><span class="nf">Execute</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="material-ids">
<h3><span class="section-number">3.1.2.3. </span>Material IDs<a class="headerlink" href="#material-ids" title="Link to this heading"></a></h3>
<p>When using the in-house <code class="docutils literal notranslate"><span class="pre">OrthogonalMeshGenerator</span></code>, no material IDs are assigned. The user needs to
assign material IDs to all cells. Here, we have a homogeneous domain, so we assign a material ID
with value 0 for each cell in the spatial domain.</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Set Material IDs</span>
<span class="nv">mesh</span><span class="p">.</span><span class="nf">SetUniformMaterialID</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="materials">
<h2><span class="section-number">3.1.3. </span>Materials<a class="headerlink" href="#materials" title="Link to this heading"></a></h2>
<p>We create a material and add two properties to it:</p>
<ul class="simple">
<li><p>TRANSPORT_XSECTIONS for the transport cross sections, and</p></li>
<li><p>ISOTROPIC_MG_SOURCE for the isotropic volumetric source</p></li>
</ul>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Add materials</span>
<span class="nv">materials</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span>
<span class="nv">materials</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">mat</span><span class="p">.</span><span class="nf">AddMaterial</span><span class="p">(</span><span class="s2">&quot;Material_A&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="cross-sections">
<h2><span class="section-number">3.1.4. </span>Cross Sections<a class="headerlink" href="#cross-sections" title="Link to this heading"></a></h2>
<p>We assign the cross sections to the material by loading the file containing the cross sections. See the tutorials’
section on materials for more details on cross sections.</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="nv">xs_matA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">xs</span><span class="p">.</span><span class="nf">LoadFromOpenSn</span><span class="p">(</span><span class="s2">&quot;xs_1g_MatA.xs&quot;</span><span class="p">)</span>
<span class="nv">materials</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="nf">SetTransportXSections</span><span class="p">(</span><span class="nv">xs_matA</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="volumetric-source">
<h2><span class="section-number">3.1.5. </span>Volumetric Source<a class="headerlink" href="#volumetric-source" title="Link to this heading"></a></h2>
<p>We create a lua table containing the volumetric multigroup source and assign it to the material by passing that array.</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="nv">num_groups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="nv">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span>
<span class="kr">for</span><span class="w"> </span><span class="nv">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nv">num_groups</span><span class="w"> </span><span class="kr">do</span>
<span class="w">  </span><span class="nv">src</span><span class="p">[</span><span class="nv">g</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span>
<span class="kr">end</span>
<span class="nv">mg_src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">xs</span><span class="p">.</span><span class="py">IsotropicMultiGroupSource</span><span class="p">.</span><span class="nf">FromArray</span><span class="p">(</span><span class="nv">src</span><span class="p">)</span>
<span class="nv">materials</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="nf">SetIsotropicMGSource</span><span class="p">(</span><span class="nv">mg_src</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="angular-quadrature">
<h2><span class="section-number">3.1.6. </span>Angular Quadrature<a class="headerlink" href="#angular-quadrature" title="Link to this heading"></a></h2>
<p>We create a product Gauss-Legendre-Chebyshev angular quadrature and pass the number of <strong>positive</strong> polar cosines
(here <code class="docutils literal notranslate"><span class="pre">npolar</span> <span class="pre">=</span> <span class="pre">2</span></code>) and the number of azimuthal subdivisions in <strong>one quadrant</strong> (<code class="docutils literal notranslate"><span class="pre">nazimu</span> <span class="pre">=</span> <span class="pre">1</span></code>).
This creates a 3D angular quadrature.</p>
<p>We finish by optimizing the quadrature to only use the positive hemisphere for 2D simulations.</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Setup the Angular Quadrature</span>
<span class="nv">nazimu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="nv">npolar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span>
<span class="nv">pquad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">aquad</span><span class="p">.</span><span class="nf">CreateProductQuadrature</span><span class="p">(</span><span class="nv">GAUSS_LEGENDRE_CHEBYSHEV</span><span class="p">,</span><span class="w"> </span><span class="nv">nazimu</span><span class="p">,</span><span class="w"> </span><span class="nv">npolar</span><span class="p">)</span>
<span class="nv">aquad</span><span class="p">.</span><span class="nf">OptimizeForPolarSymmetry</span><span class="p">(</span><span class="nv">pquad</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">math.pi</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="linear-boltzmann-solver">
<h2><span class="section-number">3.1.7. </span>Linear Boltzmann Solver<a class="headerlink" href="#linear-boltzmann-solver" title="Link to this heading"></a></h2>
<section id="options-for-the-linear-boltzmann-solver-lbs">
<h3><span class="section-number">3.1.7.1. </span>Options for the Linear Boltzmann Solver (LBS)<a class="headerlink" href="#options-for-the-linear-boltzmann-solver-lbs" title="Link to this heading"></a></h3>
<p>In the LBS block, we provide</p>
<ul class="simple">
<li><p>the number of energy groups,</p></li>
<li><p>the groupsets (with 0-indexing), the handle for the angular quadrature, the angle aggregation, the solver type,
tolerances, and other solver options.</p></li>
</ul>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Setup LBS parameters</span>
<span class="nv">lbs_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">num_groups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">num_groups</span><span class="p">,</span>
<span class="w">  </span><span class="nv">groupsets</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nv">groups_from_to</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="nv">angular_quadrature</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">pquad</span><span class="p">,</span>
<span class="w">      </span><span class="nv">angle_aggregation_num_subsets</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">      </span><span class="nv">inner_linear_method</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;petsc_gmres&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nv">l_abs_tol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0e-6</span><span class="p">,</span>
<span class="w">      </span><span class="nv">l_max_its</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">300</span><span class="p">,</span>
<span class="w">      </span><span class="nv">gmres_restart_interval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">  </span><span class="p">},</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="putting-the-linear-boltzmann-solver-together">
<h3><span class="section-number">3.1.7.2. </span>Putting the Linear Boltzmann Solver Together<a class="headerlink" href="#putting-the-linear-boltzmann-solver-together" title="Link to this heading"></a></h3>
<p>We then create the physics solver, initialize it, and execute it.</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="nv">phys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">lbs</span><span class="p">.</span><span class="py">DiscreteOrdinatesSolver</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="nv">lbs_block</span><span class="p">)</span>
<span class="c1">-- Initialize and Execute Solver</span>
<span class="nv">ss_solver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">lbs</span><span class="p">.</span><span class="py">SteadyStateSolver</span><span class="p">.</span><span class="nf">Create</span><span class="p">({</span><span class="w"> </span><span class="nv">lbs_solver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">phys</span><span class="w"> </span><span class="p">})</span>
<span class="nv">ss_solver</span><span class="p">:</span><span class="nf">Initialize</span><span class="p">()</span>
<span class="nv">ss_solver</span><span class="p">:</span><span class="nf">Execute</span><span class="p">()</span>
</pre></div>
</div>
</section>
</section>
<section id="post-processing-via-field-functions">
<h2><span class="section-number">3.1.8. </span>Post-Processing via Field Functions<a class="headerlink" href="#post-processing-via-field-functions" title="Link to this heading"></a></h2>
<p>We extract the scalar flux (i.e., the first entry in the field function list; recall that lua
indexing starts at 1) and export it to a VTK file whose name is supplied by the user. See the tutorials’ section
on post-processing for more details on field functions.</p>
<p>The resulting scalar flux is shown below:</p>
<p><img alt="Scalar_flux" src="../../../_images/first_example_scalar_flux.png" /></p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Retrieve field functions and export them</span>
<span class="nv">fflist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">lbs</span><span class="p">.</span><span class="nf">GetScalarFieldFunctionList</span><span class="p">(</span><span class="nv">phys</span><span class="p">)</span>
<span class="nv">vtk_basename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;first_example&quot;</span>
<span class="nv">fieldfunc</span><span class="p">.</span><span class="nf">ExportToVTK</span><span class="p">(</span><span class="nv">fflist</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="nv">vtk_basename</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="possible-extensions">
<h2><span class="section-number">3.1.9. </span>Possible Extensions<a class="headerlink" href="#possible-extensions" title="Link to this heading"></a></h2>
<ol class="arabic simple">
<li><p>Change the number of MPI processes (you may want to delete the safeguard at the top of the input file to run with any number of MPI ranks);</p></li>
<li><p>Change the spatial resolution by increasing or decreasing the number of cells;</p></li>
<li><p>Change the angular resolution by increasing or decreasing the number of polar and azimuthal subdivisions.</p></li>
</ol>
</section>
<hr class="docutils" />
<section id="the-complete-input-is-below">
<h2><span class="section-number">3.1.10. </span>The complete input is below:<a class="headerlink" href="#the-complete-input-is-below" title="Link to this heading"></a></h2>
<p>You can copy/paste the text below or look in the file named <code class="docutils literal notranslate"><span class="pre">tutorials/lbs/first/first_example.lua</span></code>:</p>
<div class="highlight-lua notranslate"><div class="highlight"><pre><span></span><span class="c1">-- Check num_procs</span>
<span class="nv">num_procs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span>
<span class="kr">if</span><span class="w"> </span><span class="nv">check_num_procs</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">nil</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="nv">number_of_processes</span><span class="w"> </span><span class="o">~=</span><span class="w"> </span><span class="nv">num_procs</span><span class="w"> </span><span class="kr">then</span>
<span class="w">  </span><span class="nf">Log</span><span class="p">(</span>
<span class="w">    </span><span class="nv">LOG_0ERROR</span><span class="p">,</span>
<span class="w">    </span><span class="s2">&quot;Incorrect amount of processors. &quot;</span>
<span class="w">      </span><span class="o">..</span><span class="w"> </span><span class="s2">&quot;Expected &quot;</span>
<span class="w">      </span><span class="o">..</span><span class="w"> </span><span class="nb">tostring</span><span class="p">(</span><span class="nv">num_procs</span><span class="p">)</span>
<span class="w">      </span><span class="o">..</span><span class="w"> </span><span class="s2">&quot;. Pass check_num_procs=false to override if possible.&quot;</span>
<span class="w">  </span><span class="p">)</span>
<span class="w">  </span><span class="nb">os.exit</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
<span class="kr">end</span>


<span class="c1">-- Setup the mesh</span>
<span class="nv">nodes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span>
<span class="nv">n_cells</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span>
<span class="nv">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.</span>
<span class="nv">xmin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="nv">length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.</span>
<span class="nv">dx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nv">n_cells</span>
<span class="kr">for</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="nv">n_cells</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="kr">do</span>
<span class="w">  </span><span class="nv">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="nv">nodes</span><span class="p">[</span><span class="nv">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">xmin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">k</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nv">dx</span>
<span class="kr">end</span>

<span class="nv">meshgen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">mesh</span><span class="p">.</span><span class="py">OrthogonalMeshGenerator</span><span class="p">.</span><span class="nf">Create</span><span class="p">({</span>
<span class="w">  </span><span class="nv">node_sets</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nv">nodes</span><span class="p">,</span><span class="w"> </span><span class="nv">nodes</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="nv">partitioner</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">mesh</span><span class="p">.</span><span class="py">KBAGraphPartitioner</span><span class="p">.</span><span class="nf">Create</span><span class="p">({</span>
<span class="w">    </span><span class="nv">nx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="nv">ny</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="nv">xcuts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="nv">ycuts</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">}),</span>
<span class="p">})</span>

<span class="nv">meshgen</span><span class="p">:</span><span class="nf">Execute</span><span class="p">()</span>


<span class="c1">-- Set Material IDs</span>
<span class="nv">mesh</span><span class="p">.</span><span class="nf">SetUniformMaterialID</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


<span class="c1">-- Add materials</span>
<span class="nv">materials</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span>
<span class="nv">materials</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">mat</span><span class="p">.</span><span class="nf">AddMaterial</span><span class="p">(</span><span class="s2">&quot;Material_A&quot;</span><span class="p">)</span>


<span class="nv">xs_matA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">xs</span><span class="p">.</span><span class="nf">LoadFromOpenSn</span><span class="p">(</span><span class="s2">&quot;xs_1g_MatA.xs&quot;</span><span class="p">)</span>
<span class="nv">materials</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="nf">SetTransportXSections</span><span class="p">(</span><span class="nv">xs_matA</span><span class="p">)</span>


<span class="nv">num_groups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="nv">src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span>
<span class="kr">for</span><span class="w"> </span><span class="nv">g</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="nv">num_groups</span><span class="w"> </span><span class="kr">do</span>
<span class="w">  </span><span class="nv">src</span><span class="p">[</span><span class="nv">g</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span>
<span class="kr">end</span>
<span class="nv">mg_src</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">xs</span><span class="p">.</span><span class="py">IsotropicMultiGroupSource</span><span class="p">.</span><span class="nf">FromArray</span><span class="p">(</span><span class="nv">src</span><span class="p">)</span>
<span class="nv">materials</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="nf">SetIsotropicMGSource</span><span class="p">(</span><span class="nv">mg_src</span><span class="p">)</span>


<span class="c1">-- Setup the Angular Quadrature</span>
<span class="nv">nazimu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="nv">npolar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span>
<span class="nv">pquad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">aquad</span><span class="p">.</span><span class="nf">CreateProductQuadrature</span><span class="p">(</span><span class="nv">GAUSS_LEGENDRE_CHEBYSHEV</span><span class="p">,</span><span class="w"> </span><span class="nv">nazimu</span><span class="p">,</span><span class="w"> </span><span class="nv">npolar</span><span class="p">)</span>
<span class="nv">aquad</span><span class="p">.</span><span class="nf">OptimizeForPolarSymmetry</span><span class="p">(</span><span class="nv">pquad</span><span class="p">,</span><span class="w"> </span><span class="mf">4.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">math.pi</span><span class="p">)</span>


<span class="c1">-- Setup LBS parameters</span>
<span class="nv">lbs_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nv">num_groups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">num_groups</span><span class="p">,</span>
<span class="w">  </span><span class="nv">groupsets</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nv">groups_from_to</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="nv">angular_quadrature</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">pquad</span><span class="p">,</span>
<span class="w">      </span><span class="nv">angle_aggregation_num_subsets</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">      </span><span class="nv">inner_linear_method</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;petsc_gmres&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nv">l_abs_tol</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0e-6</span><span class="p">,</span>
<span class="w">      </span><span class="nv">l_max_its</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">300</span><span class="p">,</span>
<span class="w">      </span><span class="nv">gmres_restart_interval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">,</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">  </span><span class="p">},</span>
<span class="p">}</span>

<span class="nv">phys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">lbs</span><span class="p">.</span><span class="py">DiscreteOrdinatesSolver</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="nv">lbs_block</span><span class="p">)</span>

<span class="c1">-- Initialize and Execute Solver</span>
<span class="nv">ss_solver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">lbs</span><span class="p">.</span><span class="py">SteadyStateSolver</span><span class="p">.</span><span class="nf">Create</span><span class="p">({</span><span class="w"> </span><span class="nv">lbs_solver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">phys</span><span class="w"> </span><span class="p">})</span>

<span class="nv">ss_solver</span><span class="p">:</span><span class="nf">Initialize</span><span class="p">()</span>
<span class="nv">ss_solver</span><span class="p">:</span><span class="nf">Execute</span><span class="p">()</span>


<span class="c1">-- Retrieve field functions and export them</span>
<span class="nv">fflist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">lbs</span><span class="p">.</span><span class="nf">GetScalarFieldFunctionList</span><span class="p">(</span><span class="nv">phys</span><span class="p">)</span>
<span class="nv">vtk_basename</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;first_example&quot;</span>
<span class="nv">fieldfunc</span><span class="p">.</span><span class="nf">ExportToVTK</span><span class="p">(</span><span class="nv">fflist</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="nv">vtk_basename</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../index.html" class="btn btn-neutral float-left" title="3. Linear Boltzmann Solver" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../../../coding_standard.html" class="btn btn-neutral float-right" title="Coding Standards" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023-present, OpenSn team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>